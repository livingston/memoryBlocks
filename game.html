<!DOCTYPE html>
<!--
      __         __   ___      ___   __
     |  |       |  |  \  \    /  /  |  |
     |  |       |  |   \  \  /  /   |  |
     |  |____   |  |    \  \/  /    |  |
     |_______|  |__|     \____/     |__|
        HAND CODED BY LIVINGSTON SAMUEL
-->
<html>
  <head>
    <meta charset="utf-8" />
    <title>Memory Blocks</title>
    <link href='http://fonts.googleapis.com/css?family=Arvo' rel='stylesheet' type='text/css'>
    <style>
      html, body, div, h3 { margin:0; padding:0 }
      html, body { height:100%; overflow:hidden }
      body { z-index:10; position:relative }
      #board { margin:10px; overflow:hidden; text-align:center }
      #board canvas { margin:0 auto }
      h3 { font-family: 'Arvo', arial, serif; font-size:24px; text-align:center; margin:10px 0 }
    </style>
    <meta name="author" content="Livingston Samuel" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
  </head>
  <body>
    <h3>Memory Blocks</h3>
    <div id='board'></div>
    <!-- fork me at https://github.com/livingston/ -->

    <script>
      /*! Memory Blocks

          @author Livingston Samuel
          @version 0.2f
      */

      (function ( window, document, Math ) {
        var body = document.body,
            root = document.getElementById( 'board' ),
            MemoryBlocks, Extend;

        if ( !document.createElement('canvas').getContext ) {
          body.appendChild( document.createTextNode( 'Your browser doesn\'t support canvas.' ) );
          return
        }

        Extend = function ( what, wit ) {
          var ext = {}, name, t;

          for ( name in wit ) {
            t = wit[ name ];
            if ( wit.hasOwnProperty( name ) ) {
              ext[ name ] = t;
            }
          }

          for ( name in what ) {
            t = what[ name ];
            if ( what.hasOwnProperty( name ) ) {
              u = ext[ name ];
              ext[ name ] = ( typeof u != 'undefined' ) ? u : t;
            }
          }

          return ext
        };

        MemoryBlocks = function ( options ) {
          var defaults = {
            root: document.body,
            timeout: 60,
            minLevel: 3,
            maxLevel: 10,
            blockSize: 100,
            gridRatio: '1:1'
          },
          options = Extend( defaults, options );

          this.options = options;

          this.calculateMetrics();
          this.setup();
        };

        MemoryBlocks.prototype.loadStyles = function () {
          var styles = document.createElement( 'style' ),
              canvas = this.context.canvas;

          styles.innerHTML = '#MB_status { padding:14px 0 13px; text-align:center; position:absolute; top:' +
                             ( canvas.offsetTop + ( canvas.height - this.options.blockSize ) / 2 ) +
                             'px; width:100%; font-size:24px; line-height:1em; border:0 solid; border-width:3px 0 } ' +
                             '#MB_status.info { background:#eee; color:#999 } ' +
                             '#MB_status.gamecomplete { background:#9dd09d; color:#007300 } ' +
                             '#MB_status.gameover { background:#fe381e; color:#8f2011 } ' +
                             '.mb_hidden { display:none } ' +
                             '#MB_SPRITES { position:absolute; top:0; right:0; display:none }' +
                             '#MB_CONTROLS button { padding:10px 20px 8px; border:1px solid; border-radius:10px; font-size:16px; margin:7px; font-weight:bold; text-transform:uppercase }' +
                             '#MB_START { color:#3e533e; background:#9dd09d }' +
                             '#MB_STOP { color:#ea2e0f; background:#ea9587 }';
          this.options.root.appendChild(styles);
        };

        MemoryBlocks.prototype.setupStatus = function () {
          var statusElem = document.createElement( 'div' );

          statusElem.id = 'MB_status';
          statusElem.className = 'mb_hidden';
          this.statusElem = statusElem;
          this.options.root.parentNode.appendChild(statusElem);
        };

        MemoryBlocks.prototype.addControls = function () {
          var frag = document.createElement('div'),
              startBtn = document.createElement( 'button' ),
              stopBtn = startBtn.cloneNode( false );

          frag.id = 'MB_CONTROLS';
          startBtn.id = 'MB_START';
          startBtn.innerHTML = 'Start';

          stopBtn.id = 'MB_STOP';
          stopBtn.className = 'mb_hidden';
          stopBtn.innerHTML = 'Stop';

          frag.appendChild( startBtn );
          frag.appendChild( stopBtn );

          this.options.root.appendChild( frag );

          this.controls = { start: startBtn, stop: stopBtn };
          var self = this;
          startBtn.addEventListener( 'click', function () {
            self.start();
            this.className = 'mb_hidden';
            stopBtn.className = '';
          }, false );

          stopBtn.addEventListener( 'click', function () {
            self.stop();
            this.className = 'mb_hidden';
            startBtn.className = '';
          }, false );
        };

        MemoryBlocks.prototype.setupSprites = function () {
          var sprite = document.createElement( 'canvas' ),
              ctx = sprite.getContext( '2d' ),
              size = this.options.blockSize,
              gradientActive, gradientInactive,
              itemsInSprite = 3, space = 10,
              opts = this.options, deg = Math.PI/180,
              createGradient = function ( color1, color2 ) {
                var g = ( size * 50 / size ),
                    gradient = ctx.createRadialGradient( g, g, size/2, g, g, size );

                gradient.addColorStop( 0, color1 );
                gradient.addColorStop( 1, color2 );

                return gradient;
              },
              setBoxSprite = function ( x, y, style ) {
                ctx.save();
                ctx.translate( x, y );

                ctx.moveTo( 0, 0 );
                ctx.fillStyle = style;
                ctx.fillRect( 0, 0, size, size );

                ctx.restore();
              }, step = size + 10;

          sprite.width = ( size + space ) * 3;
          sprite.height = size;
          sprite.id = 'MB_SPRITES';

          setBoxSprite( 0, 0, createGradient( '#f0262a', '#aa1a1e' ) );
          setBoxSprite( step, 0, createGradient( '#e7e7e7', '#a1a1a1' ) );

          var tdata = ctx.getImageData( step, 0, size, size );
          ctx.putImageData( tdata, step * 2, 0 );

          ctx.save();
          ctx.translate( step * 2 + size / 6, size / 10 );
          ctx.rotate( 45 * deg );
          ctx.moveTo( 0, 0 );
          ctx.fillStyle = createGradient( '#f0262a', '#aa1a1e' )
          ctx.fillRect( 0, 0, size, size / 10 );
          ctx.restore()

          ctx.save();
          ctx.translate( step * 2 + size / 8, size / 1.25 );
          ctx.rotate( -45 * deg );
          ctx.fillStyle = createGradient( '#f0262a', '#aa1a1e' );
          ctx.fillRect( 0, 0, size, size / 10 );
          ctx.restore();

          body.appendChild( sprite );
          this.sprite = ctx;
        };

        MemoryBlocks.prototype.calculateMetrics = function () {
          var opts = this.options,
              gridRatio = opts.gridRatio.split( ':' ),
              size = opts.blockSize,
              metrics = {},
              space = size/50,
              sizeFactor = ( size + space );

          metrics.col = opts.maxLevel * parseInt( gridRatio[ 0 ], 10 );
          metrics.row = opts.maxLevel * parseInt( gridRatio[ 1 ], 10 );
          metrics.space = space;
          metrics.sizeFactor = sizeFactor;
          metrics.width = sizeFactor * metrics.col;
          metrics.height = sizeFactor * metrics.row;

          this.metrics = metrics;
        };

        MemoryBlocks.prototype.setup = function () {
          var board = document.createElement( 'canvas' ),
              metrics = this.metrics,
              opts = this.options,
              size = opts.blockSize;

          board.width = metrics.width;
          board.height = metrics.height;

          opts.root.appendChild( board );

          this.context = board.getContext( '2d' );
          this.loadStyles();
          this.setupStatus();
          this.setupSprites();
          this.addControls();

          var x = 0, y = 0, m = metrics.col, o = metrics.row, n,
              blocks = {}, i = 0, ty, sizeFactor = metrics.sizeFactor;

          while ( o-- ) {
            n = m;
            x = 0;
            ty = ( y / size ).toFixed( 0 );
            while ( n-- ) {
              this.drawBlock( x, y );
              blocks['' + ( x / size ).toFixed( 0 ) + ty] = [ x, y ];

              x = x + sizeFactor;
            }
            y = y + sizeFactor;
          }
          this.blocks = blocks;
        };

        MemoryBlocks.prototype.setStatus = function ( msg, type ) {
          var statusElem = this.statusElem;
          statusElem.textContent = msg || '';
          statusElem.className = type || 'info';

          setTimeout( function () {
            statusElem.className = 'mb_hidden';
          }, 5000 )
        };

        MemoryBlocks.prototype.drawBlock = function ( x, y, type ) {
          var self = this,
              size = self.options.blockSize,
              ctx = self.context,
              getData = {
                blank: function () {
                  return self.sprite.getImageData( size + 10, 0, size, size )
                },
                select: function () {
                  return self.sprite.getImageData( 0, 0, size, size )
                },
                invalid: function () {
                  return self.sprite.getImageData( ( size + 10 ) * 2, 0, size, size )
                }
              };

          ctx.putImageData( getData[ type || 'blank' ](), x, y )
        };

        MemoryBlocks.prototype.bind = function () {
          var self = this,
              board = self.context.canvas,
              size = self.options.blockSize,
              oX = board.offsetLeft,
              oY = board.offsetTop,
              controls = this.controls,
              sizeFactor = self.metrics.sizeFactor,
              handleClick = function ( e ) {
                e = e || event;
                var x = e.clientX - oX,
                    y = e.clientY - oY;

                if ( typeof self.possibleClicks == 'undefined' ) {
                  return;
                } else if ( self.possibleClicks-- ) {
                  var sX = Math.abs( Math.floor( x / sizeFactor ) ),
                      sY = Math.abs( Math.floor( y / sizeFactor ) ),
                      xy = '' + sX + sY,
                      coord = self.blocks[ xy ];
                  if ( self.active.indexOf( xy ) != -1 ) {
                    self.drawBlock( coord[0], coord[1], 'select' );

                    if ( self.possibleClicks == 0 ) {
                      self.setStatus( 'Congratulations!', 'gamecomplete' );
                    }
                    return;
                  } else {
                    self.drawBlock( coord[0], coord[1], 'invalid' );
                  }
                }

                self.setStatus( 'GAME OVER', 'gameover' );
                self.unbind();
              };

          this.handleClick = handleClick.bind(this);

          board.addEventListener( 'click', this.handleClick, false);
        };

        MemoryBlocks.prototype.unbind = function () {
          this.active = [];
          delete this.possibleClicks;
          this.context.canvas.removeEventListener( 'click', this.handleClick, false);
        };

        MemoryBlocks.prototype.clear = function () {
          var block = this.blocks, coord,
              opt = this.options,
              metrics = this.metrics,
              col = metrics.col,
              row = metrics.row, r, tc;

          while ( col-- ) {
            r = row;
            tc = col + '';
            while ( r-- ) {
              coord = block[ tc + r ];

              this.drawBlock( coord[0], coord[1] );
            }
          }
        };

        MemoryBlocks.prototype.start = function () {
          var blocks = this.blocks,
              opt = this.options,
              size = opt.blockSize,
              metrics = this.metrics,
              maxX = metrics.col-1,
              maxY = metrics.row-1,
              n = maxX * maxY,
              h = Math.floor( n/2 ),
              maxP = Math.floor( Math.random() * n ),
              tX, tY, f,
              coord, self = this;
          this.active = [];
          this.clear();
          if ( maxP < h ) {
            maxP = h;
          }

          while ( maxP-- ) {
            tX = Math.floor( Math.random() * maxX );
            tY = Math.floor( Math.random() * maxY );
            f = tX + '' + tY;

            if ( this.active.indexOf( f ) == -1 ) {
              this.active.push( f );
              coord = blocks[ f ];
              this.drawBlock( coord[0], coord[1], 'select' );
            }
          }

          this.timer = setTimeout( function () {
            self.clear();

            self.possibleClicks = self.active.length;
            self.bind();

          }, opt.timeout*1000 );
        };

        MemoryBlocks.prototype.stop = function () {
          clearTimeout( this.timer );
          this.unbind();
          this.clear();
        };

        this.mb = new MemoryBlocks({ root: root, blockSize: 50, maxLevel: 5, timeout: 5 });
      }(window, document, Math));
    </script>
  </body>
</html>